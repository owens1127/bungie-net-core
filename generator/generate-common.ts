import { DefInfo, getReferencedTypes, getRef } from './util.js';
import _ from 'underscore';
import path from 'path';
import fs from 'fs';
import mkdirp from 'mkdirp';
import { OpenAPIObject, SchemaObject, ReferenceObject } from 'openapi3-ts';

export function generateHeader(doc: OpenAPIObject): string {
  const { info } = doc;
  return `/**
 * ${info.title}
 * ${info.description}
 *
 * OpenAPI spec version: ${info.version}
 * Contact: ${info.contact!.email}
 *
 * NOTE: This class is auto generated by the bungie-api-typedef code generator program,
 * adapted from <@link https://github.com/DestinyItemManager/bungie-api-ts>
 * Repository: <@link https://github.com/owensimpson/bungie-api-typedef>
 * Do not edit these files manually.
 */`;
}

export function addImport(
  doc: OpenAPIObject,
  schema: SchemaObject | ReferenceObject,
  componentByDef: { [def: string]: DefInfo },
  importFiles: { [filename: string]: Set<string> }
) {

  const typeRef = getReferencedTypes(schema);

  if (typeRef && componentByDef[typeRef]) {

    if (componentByDef[typeRef].typeName.includes('<')) {
      const split = componentByDef[typeRef].typeName.split(new RegExp('([<|>])'))
      const intrface = split[0];
      importFiles[`generics/${intrface}.d.ts`] = importFiles[`$generics/${intrface}.d.ts`] || new Set();
      importFiles[`generics/${intrface}.d.ts`].add(intrface);

      const component = getRef(doc, typeRef);
      if (component) {
        const property = component.properties!.data ?? component.properties!.Response;
        if (property) {
          addImport(doc, property, componentByDef, importFiles);
          return;
        }
      }
    } else {
      const filename = componentByDef[typeRef].filename;
      importFiles[filename] = importFiles[filename] || new Set();
      importFiles[filename].add(componentByDef[typeRef].typeName);
    }

  }
}

export function generateImports(
  filename: string,
  importFiles: { [filename: string]: Set<string> }
): string {
  return _.compact(
    _.map(importFiles, (types, f) => {
      const absImport = path.resolve('generated-src', f);
      const absDest = path.resolve(filename);
      if (absImport === absDest) {
        return undefined;
      }
      let relativePath = path.relative(path.dirname(absDest), absImport).replace(/(\.d)?\.ts$/, '');
      if (!relativePath.startsWith('.')) {
        relativePath = './' + relativePath;
      }
      if (path.sep === '\\') relativePath = relativePath.replace(/\\/g, '/');
      return `import { ${[...types].sort().join(',  ')} } from '${relativePath}';`;
    })
  )
    .sort()
    .join('\n');
}


export function commentHyperReference(def: string) {
  return `@see {@link https://bungie-net.github.io/${def}}`;
}

export function docComment(text: string, params?: string[]) {
  const lines = _.flatten(
    text
      .trim()
      .split('\n')
      .map((l) => l.replace(/(.{1,80}(?:\W|$))/g, '$1\n').split('\n'))
  ).map((s: string) => s.trim());
  lines.pop();
  if (params) lines.push(...params)

  if (lines.length === 1 && (params === undefined || params.length === 0)) {
    return `/** ${lines} */`;
  } else {
    return `/**
${lines.map((line) => (line.length ? ' * ' + line : ' *')).join('\n')}
*/`;
  }

}

export function indent(text: string, indentLevel: number) {
  const lines = text.split('\n');
  return lines.map((line) => '  '.repeat(indentLevel) + line).join('\n');
}

export async function writeOutFile(filename: string, contents: string) {
  try {
    await mkdirp(path.dirname(filename));

    fs.writeFile(filename, contents, null, (error) => {
    });
  } catch (e) {
    console.error(e);
  }
}
